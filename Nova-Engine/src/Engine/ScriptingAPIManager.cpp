#include <spdlog/spdlog.h>
#include "ScriptingAPIManager.h"

#include <shlwapi.h>
#include <array>
#include <iostream>

#include "Libraries/Profiling.h"

#pragma comment(lib, "shlwapi.lib") // PathRemoveFileSpecA

#include "engine.h"

class ECS;

ScriptingAPIManager::ScriptingAPIManager(Engine& engine)
	: coreClr					{ nullptr }
	, hostHandle				{ nullptr }
	, domainID					{}
	, intializeCoreClr			{ nullptr }
	, createManagedDelegate		{ nullptr }
	, shutdownCorePtr			( nullptr )
	, updateScripts				{ nullptr } 
	, addGameObjectScript		{ nullptr }
	, removeGameObjectScript	{ nullptr } 
{
	// ==========================================================
	// 1. Load the .NET Core CoreCLR library (explicit linking)
	// (this project assumes that the dll is located right next to the executable.
	// ==========================================================
	
	// Get the file path of the output directory containing coreclr.dll
	std::string runtimePath{ std::string(MAX_PATH, '\0') };
	GetModuleFileNameA(nullptr, runtimePath.data(), MAX_PATH);
	PathRemoveFileSpecA(runtimePath.data());
	runtimePath.resize(std::strlen(runtimePath.data()));
	std::string coreClrPath{ runtimePath };

	coreClrPath += "\\Coreclr.dll";

	// Load coreclr.dll
	coreClr = LoadLibraryA(coreClrPath.c_str());

	if (!coreClr) {
		spdlog::error("Failed to load CoreCLR.");
		return;
	}

	// ==========================================================
	// 2. Retrieve function pointers to interact with Core CLR.
	// ==========================================================
	try {
		intializeCoreClr		= getCoreClrFuncPtr<coreclr_initialize_ptr>("coreclr_initialize");
		createManagedDelegate	= getCoreClrFuncPtr<coreclr_create_delegate_ptr>("coreclr_create_delegate");
		shutdownCorePtr			= getCoreClrFuncPtr<coreclr_shutdown_ptr>("coreclr_shutdown");
	}
	catch (std::exception e) {
		spdlog::error("Error when attempting to retrieve function pointers from Core CLR: {}", e.what());
		return;
	}

	// ==========================================================
	// 3. Preparing arguments prior to loading the Core CLR dll.
	// - These are properties of the AppDomain.
	// ==========================================================

	// Builds a TPA List, which is a string containing all dlls relative to the executable delimited by a ;.
	std::string tpaList			{ buildTPAList(runtimePath) };
	std::array propertyKeys		{ "TRUSTED_PLATFORM_ASSEMBLIES", "APP_PATHS" };
	std::array propertyValues	{ tpaList.c_str(),runtimePath.c_str() };

	// ==========================================================
	// 4. Initializes the Core CLR through function pointers obtained in 2.
	// ==========================================================
	
	// Start CoreClr runtime
	int result = intializeCoreClr(
		runtimePath.c_str(),
		"Nova-Host",
		static_cast<int>(propertyKeys.size()),
		propertyKeys.data(),
		propertyValues.data(),
		&hostHandle,
		&domainID
	);

	if (result != S_OK) {
		std::ostringstream errorDetails;
		errorDetails << "(0x";
		errorDetails << std::hex << result;
		errorDetails << ")Failed to initialize CoreCLR";
		throw std::runtime_error(errorDetails.str());
	}

	// ==========================================================
	// 5. We can now interact with the DLL generated by Nova-Scripting API, acting as the bridge between
	// native code and managed code!
	// 
	// We retrieve function pointers from the Nova-Scripting API for interaction.
	// ==========================================================
	
	// Get the functions to run the api
	try {
		using InitFunctionPtr = void(*)(ECS&, const char*);

		InitFunctionPtr initScriptAPIFuncPtr	= GetFunctionPtr<InitFunctionPtr>("Interface", "init");
		updateScripts							= GetFunctionPtr<UpdateFunctionPtr>("Interface", "update");
		addGameObjectScript						= GetFunctionPtr<AddScriptFunctionPtr>("Interface", "addGameObjectScript");
		removeGameObjectScript					= GetFunctionPtr<RemoveScriptFunctionPtr>("Interface", "removeGameObjectScript");
		getScriptNames							= GetFunctionPtr<GetScriptsFunctionPtr>("Interface", "getScriptNames");
		initScriptAPIFuncPtr(engine.ecs, runtimePath.c_str());
	}
	catch (std::exception e) {
		spdlog::error("Failed to get function pointers from C++/CLI API side. {}", e.what());
		return;
	}
}

ScriptingAPIManager::~ScriptingAPIManager()
{
	// Shut down CoreClr
	int result{ shutdownCorePtr(hostHandle,domainID) };

	if (result != S_OK) {
		std::ostringstream errorDetails;
		errorDetails << "(0x";
		errorDetails << std::hex << result;
		errorDetails << ")Failed to shut down CoreCLR";

		spdlog::error("{}", errorDetails.str());
	}
}

std::string ScriptingAPIManager::buildTPAList(const std::string& directory)
{
	const std::string search_path{ directory + "\\*.dll" };

	std::ostringstream tpaList;

	// Search directory for TPAs(.dll)
	WIN32_FIND_DATAA findData;
	HANDLE fileHandle{ FindFirstFileA(search_path.c_str(), &findData) };
	if (fileHandle != INVALID_HANDLE_VALUE) {
		do {
			tpaList << directory << '\\' << findData.cFileName << ';';
		} while (FindNextFileA(fileHandle, &findData));
		FindClose(fileHandle);
	}
	return tpaList.str();
}
void ScriptingAPIManager::update() {
	ZoneScoped;
	updateScripts();
}
void ScriptingAPIManager::loadScriptIntoAPI(unsigned int entityID, const char* scriptName){ addGameObjectScript(entityID, scriptName); }
void ScriptingAPIManager::removeScriptFromAPI(unsigned int entityID, const char* scriptName) { removeGameObjectScript(entityID, scriptName); }
std::vector<std::string> ScriptingAPIManager::getAvailableScripts(){ return getScriptNames(); }

