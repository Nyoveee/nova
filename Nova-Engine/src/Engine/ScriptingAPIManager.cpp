#include "ScriptingAPIManager.h"

#include "ResourceManager/resourceManager.h"
#include "scriptAsset.h"
#include "Profiling.h"
#include "Logger.h"
#include <shlwapi.h>
#include <array>
#include <iostream>
#include <filesystem>
#include <tuple>
#include "window.h"
#pragma comment(lib, "shlwapi.lib") // PathRemoveFileSpecA

#include "engine.h"
#include "ECS/ECS.h"

namespace {
	constexpr float DEBOUNCING_TIME = 1.0f;
}

ScriptingAPIManager::ScriptingAPIManager(Engine& p_engine)
	: engine{p_engine}
	, runtimeDirectory{}
	, coreClr					{ nullptr }
	, hostHandle				{ nullptr }
	, domainID					{}
	, intializeCoreClr			{ nullptr }
	, createManagedDelegate		{ nullptr }
	, shutdownCorePtr			( nullptr )
	, update_			{ nullptr } 
	, addEntityScript			{ nullptr }
	, removeEntityScript_		{ nullptr } 
	, timeSinceSave				{  }
	, compileState				{ CompileState::NotCompiled }
{
	// ==========================================================
	// 1. Load the .NET Core CoreCLR library (explicit linking)
	// (this project assumes that the dll is located right next to the executable.
	// ==========================================================
	
	// Get the dotnet directory
	std::string dotnetDirectory{ getDotNetRuntimeDirectory() };

	// Get the run time directory
	runtimeDirectory = std::string(MAX_PATH, '\0');
	GetModuleFileNameA(nullptr, runtimeDirectory.data(), MAX_PATH);
	PathRemoveFileSpecA(runtimeDirectory.data());
	runtimeDirectory.resize(std::strlen(runtimeDirectory.data()));
	// Get the path of the coreclr.dll
	std::string coreClrPath{ dotnetDirectory };
	coreClrPath += "\\Coreclr.dll";

	// Load coreclr.dll
	coreClr = LoadLibraryA(coreClrPath.c_str());

	if (!coreClr) {
		Logger::error("Failed to load CoreCLR.");
		return;
	}

	// ==========================================================
	// 2. Retrieve function pointers to interact with Core CLR.
	// ==========================================================
	try {
		intializeCoreClr		= getCoreClrFuncPtr<coreclr_initialize_ptr>("coreclr_initialize");
		createManagedDelegate	= getCoreClrFuncPtr<coreclr_create_delegate_ptr>("coreclr_create_delegate");
		shutdownCorePtr			= getCoreClrFuncPtr<coreclr_shutdown_ptr>("coreclr_shutdown");
	}
	catch (std::exception e) {
		Logger::error("Error when attempting to retrieve function pointers from Core CLR: {}", e.what());
		return;
	}

	// ==========================================================
	// 3. Preparing arguments prior to loading the Core CLR dll.
	// - These are properties of the AppDomain.
	// ==========================================================

	// Builds a TPA List, which is a string containing all dlls relative to the executable delimited by a ;.
	std::string tpaList			{ buildTPAList(dotnetDirectory) + buildTPAList(runtimeDirectory)};
	std::array propertyKeys		{ "TRUSTED_PLATFORM_ASSEMBLIES", "APP_PATHS" };
	// App path is the location of the c++/cli assembly to check. In part 5, the assembly is shown as "Interface", matching the one in scriptingapi project
	std::array propertyValues	{ tpaList.c_str(), runtimeDirectory.c_str()};

	// ==========================================================
	// 4. Initializes the Core CLR through function pointers obtained in 2.
	// ==========================================================
	
	// Start CoreClr runtime
	int result = intializeCoreClr(
		dotnetDirectory.c_str(),
		"Nova-Host",
		static_cast<int>(propertyKeys.size()),
		propertyKeys.data(),
		propertyValues.data(),
		&hostHandle,
		&domainID
	);

	if (result != S_OK) {
		std::ostringstream errorDetails;
		errorDetails << "(0x";
		errorDetails << std::hex << result;
		errorDetails << ")Failed to initialize CoreCLR";
		throw std::runtime_error(errorDetails.str());
	}

	// ==========================================================
	// 5. We can now interact with the DLL generated by Nova-Scripting API, acting as the bridge between
	// native code and managed code!
	// 
	// We retrieve function pointers from the Nova-Scripting API for interaction.
	// ==========================================================
	
	// Get the functions to run the api
	try {
		using InitFunctionPtr = void(*)(Engine&, const char*);

		InitFunctionPtr initScriptAPIFuncPtr	= GetFunctionPtr<InitFunctionPtr>("Interface", "init");
		update_							        = GetFunctionPtr<UpdateFunctionPtr>("Interface", "update");
		loadAssembly                            = GetFunctionPtr<LoadScriptsFunctionPtr>("Interface", "loadAssembly");
		unloadAssembly                          = GetFunctionPtr<UnloadScriptsFunctionPtr>("Interface", "unloadAssembly");
		addEntityScript						    = GetFunctionPtr<AddScriptFunctionPtr>("Interface", "addEntityScript");
		removeEntityScript_					    = GetFunctionPtr<RemoveScriptFunctionPtr>("Interface", "removeEntityScript");
		removeEntity_                           = GetFunctionPtr<RemoveEntityFunctionPtr>("Interface", "removeEntity");
		initalizeScripts                        = GetFunctionPtr<IntializeScriptsFunctionPtr>("Interface", "intializeAllScripts");
		getScriptFieldDatas_                    = GetFunctionPtr<GetScriptFieldsFunctionPtr>("Interface", "getScriptFieldDatas");
		
		setScriptFieldData		                = GetFunctionPtr<SetScriptFieldFunctionPtr>("Interface", "setScriptFieldData");
		
		// Intialize the scriptingAPI
		initScriptAPIFuncPtr(engine, runtimeDirectory.c_str());

	}
	catch (std::exception e) {
		Logger::error("Failed to get function pointers from C++/CLI API side. {}", e.what());
		return;
	}
}

ScriptingAPIManager::~ScriptingAPIManager()
{
	// Shut down CoreClr
	int result{ shutdownCorePtr(hostHandle,domainID) };

	if (result != S_OK) {
		std::ostringstream errorDetails;
		errorDetails << "(0x";
		errorDetails << std::hex << result;
		errorDetails << ")Failed to shut down CoreCLR";

		Logger::error("{}", errorDetails.str());
	}
}

std::string ScriptingAPIManager::buildTPAList(const std::string& directory)
{
	const std::string search_path{ directory + "\\*.dll" };

	std::ostringstream tpaList;

	// Search directory for TPAs(.dll)
	WIN32_FIND_DATAA findData;
	HANDLE fileHandle{ FindFirstFileA(search_path.c_str(), &findData) };
	if (fileHandle != INVALID_HANDLE_VALUE) {
		do {
			tpaList << directory << '\\' << findData.cFileName << ';';
		} while (FindNextFileA(fileHandle, &findData));
		FindClose(fileHandle);
	}
	return tpaList.str();
}

std::string ScriptingAPIManager::getDotNetRuntimeDirectory()
{
	// Check if .net is installed
	const std::filesystem::path PATH = std::filesystem::path("C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App");
	if (!std::filesystem::exists(PATH))
		return {};
	// Find the latest version 
	std::tuple<int, int, std::filesystem::path> latestVersion = { -1,-1,{} };
	for (const std::filesystem::directory_entry& dir_Entry : std::filesystem::directory_iterator(PATH))
	{
		if (!dir_Entry.is_directory())
			continue;
		std::filesystem::path dir = dir_Entry.path();
		std::string dirName = (--(dir.end()))->string();
		const int ver_Major{ std::stoi(dirName.substr(0, dirName.find_first_of('.')))};
		const int ver_Minor{ std::stoi(dirName.substr(dirName.find_last_of('.')+1, dirName.size())) };
		const int lastest_Major = std::get<0>(latestVersion);
		const int lastest_Minor = std::get<1>(latestVersion);
		if (ver_Major > lastest_Major || (ver_Major == lastest_Major && ver_Minor > lastest_Minor))
			latestVersion = { ver_Major,ver_Minor, dirName };
	}
	return PATH.string() + "\\" + std::get<2>(latestVersion).string();
}

bool ScriptingAPIManager::compileScriptAssembly()
{
	compileState = CompileState::CompilationFailed;

	unloadAssembly();
	// Project path and build command
	std::string proj_path{std::filesystem::current_path().string() + "\\Nova-Scripts\\Nova-Scripts.csproj"};

#ifdef _DEBUG
	std::wstring buildCmd = L" build \"" + std::filesystem::absolute(proj_path).wstring()
		+ L"\" -c Debug --no-self-contained -o "
		+ L"\"" + std::filesystem::current_path().wstring() + L"/Nova-Scripts/.bin/\" -r \"win-x64\""
		+ L" --artifacts-path \"" + std::filesystem::current_path().wstring() + L"/Nova-Scripts/.bin/\"";
#else
	std::wstring buildCmd = L" build \"" + std::filesystem::absolute(proj_path).wstring()
		+ L"\" -c Release --no-self-contained -o "
		+ L"\"" + std::filesystem::current_path().wstring() + L"/Nova-Scripts/.bin/\" -r \"win-x64\""
		+ L" --artifacts-path \"" + std::filesystem::current_path().wstring() + L"/Nova-Scripts/.bin/\"";
#endif
	STARTUPINFOW startInfo;
	PROCESS_INFORMATION pi;
	ZeroMemory(&startInfo, sizeof(startInfo));
	ZeroMemory(&pi, sizeof(pi));
	startInfo.cb = sizeof(startInfo);
	// Start Compiler 
	const auto launch_success = CreateProcess
	(
		L"C:\\Program Files\\dotnet\\dotnet.exe", buildCmd.data(),
		nullptr, nullptr, true, NULL, nullptr, nullptr,
		&startInfo, &pi
	);
	if (!launch_success)
	{
		auto err{ GetLastError() };
		std::stringstream hexCode{};
		hexCode << std::hex << err;
		Logger::error("Failed to launch compiler. Error code: {}", hexCode.str());
		return false;
	}
	// Wait until compiling is done
	DWORD exitCode{};
	while (true)
	{
		const auto exec_success = GetExitCodeProcess(pi.hProcess, &exitCode);
		if (!exec_success)
		{
			auto err{ GetLastError() };
			std::stringstream hexCode{};
			hexCode << std::hex << err;
			Logger::error("Failed to query process. Error code: {}", hexCode.str());
			return false;
		}
		if (exitCode != STILL_ACTIVE)
			break;
	}
	// Copy the compiled dlls into the output directory if compilation is successful
	if (exitCode == 0)
	{
		std::filesystem::copy_file
		(
			(std::filesystem::current_path().string() + "\\Nova-Scripts\\.bin\\Nova-Scripts.dll"), // Source
			(runtimeDirectory + "\\Nova-Scripts.dll"), // Destination
			std::filesystem::copy_options::overwrite_existing
		);
	}
	else
	{
		Logger::error("Failed to build Nova-Scripts");
		return false;
	}

	compileState = CompileState::Compiled;
	loadAssembly();
	return true;
}

#if 0
void ScriptingAPIManager::loadEntityScript(entt::entity entityID, ResourceID scriptID)
{
	addEntityScript(static_cast<unsigned int>(entityID), static_cast<unsigned long long>(scriptID));
}

void ScriptingAPIManager::removeEntityScript(entt::entity entityID, ResourceID scriptID)
{
	removeEntityScript_(static_cast<unsigned int>(entityID), static_cast<unsigned long long>(scriptID));
}

ENGINE_DLL_API void ScriptingAPIManager::removeEntity(entt::entity entityID)
{
	removeEntity_(static_cast<unsigned int>(entityID));
}
#endif

bool ScriptingAPIManager::isNotCompiled() const
{
	return compileState != CompileState::Compiled;
}
	
void ScriptingAPIManager::update() {
	ZoneScoped;

	update_();
}

void ScriptingAPIManager::checkIfRecompilationNeeded(float dt) {
	if (compileState != CompileState::ToBeCompiled) {
		return;
	}

	// start timer..
	timeSinceSave += dt;

	if (timeSinceSave < DEBOUNCING_TIME) {
		return;
	}

	// we attempt to recompile the script assembly
	if (compileScriptAssembly()) {

		// update the field data of all entities with affected scripts..
		for (auto&& [entity, scripts] : engine.ecs.registry.view<Scripts>().each()) {
			for (auto&& script : scripts.scriptDatas) {
				// only get script field data if this script itself has been modified.
				if (!modifiedScripts.count(script.scriptId))
					continue;
				std::vector<FieldData> temp{ script.fields };
				script.fields.clear();
				for (FieldData const& newFields : getScriptFieldDatas(script.scriptId)) {
					bool b_IsExistingField{ false };
					for (FieldData const& oldFields : temp) {
						if (oldFields.name != newFields.name)
							continue;
						script.fields.push_back(oldFields);
						b_IsExistingField = true;
						break;
					}
					if (!b_IsExistingField)
						script.fields.push_back(newFields);
				}
			}
		}

		modifiedScripts.clear();
	}

	timeSinceSave = 0;
}

std::vector<FieldData> ScriptingAPIManager::getScriptFieldDatas(ResourceID scriptID)
{
	return getScriptFieldDatas_(static_cast<std::size_t>(scriptID));
}

bool ScriptingAPIManager::hasCompilationFailed() const {
	return compileState == CompileState::CompilationFailed;
}

bool ScriptingAPIManager::startSimulation() {
	// Recompile if there is a change in script before starting simulation..
	if (compileState != CompileState::Compiled) {
		if (!compileScriptAssembly()) 
			return false;
	}

	// Instantiate all entities' script..
	for (auto&& [entity, scripts] : engine.ecs.registry.view<Scripts>().each()) {
		for (auto&& script : scripts.scriptDatas) {
			addEntityScript(static_cast<unsigned int>(entity), static_cast<std::size_t>(script.scriptId));
			for (auto&& fieldData : script.fields)
				setScriptFieldData(static_cast<unsigned int>(entity), static_cast<std::size_t>(script.scriptId), fieldData);
		}
	}

	// Call their init functions..
	initalizeScripts();
	return true;
}

void ScriptingAPIManager::stopSimulation(){
	// Reset assembly, clearing all instantiated scripts.
	unloadAssembly();
	loadAssembly();
}

void ScriptingAPIManager::OnAssetContentAddedCallback(std::string absPath) {
	if (std::filesystem::path(absPath).extension() == ".cs") {
		compileState = CompileState::ToBeCompiled;
		timeSinceSave = 0.f;
	}
}

void ScriptingAPIManager::OnAssetContentModifiedCallback(ResourceID resourceId) {
	if (engine.resourceManager.isResource<ScriptAsset>(resourceId)) {
		compileState = CompileState::ToBeCompiled;
		timeSinceSave = 0.f;

		modifiedScripts.insert(resourceId);
	}
}

void ScriptingAPIManager::OnAssetContentDeletedCallback(ResourceID resourceId) {
	(void) resourceId;
	// AssetID might disappear if assetmanager deletes it before this callback, maybe do typedAssetID or filepath instead(Overloaded callback?) 
}

