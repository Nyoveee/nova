{
    "blendingConfig": "AlphaBlending",
    "depthTestingMethod": "DepthTest",
    "cullingConfig": "Enable",
    "uniformDatas": [
        {
            "glslType": "sampler2D",
            "identifier": "albedoMap",
            "value": {
                "__variant_value": 8,
                "__variant_type": 9
            }
        },
        {
            "glslType": "ORMMap",
            "identifier": "packedMap",
            "value": {
                "__variant_value": 8,
                "__variant_type": 16
            }
        },
        {
            "glslType": "NormalMap",
            "identifier": "normalMap",
            "value": {
                "__variant_value": 8,
                "__variant_type": 13
            }
        },
        {
            "glslType": "EmissiveMap",
            "identifier": "emissiveMap",
            "value": {
                "__variant_value": 8,
                "__variant_type": 14
            }
        },
        {
            "glslType": "AlphaMap",
            "identifier": "alphaMap",
            "value": {
                "__variant_value": 8,
                "__variant_type": 15
            }
        },
        {
            "glslType": "NormalizedFloat",
            "identifier": "roughness",
            "value": {
                "__variant_value": 0.0,
                "__variant_type": 12
            }
        },
        {
            "glslType": "NormalizedFloat",
            "identifier": "metallic",
            "value": {
                "__variant_value": 0.0,
                "__variant_type": 12
            }
        },
        {
            "glslType": "NormalizedFloat",
            "identifier": "occulusion",
            "value": {
                "__variant_value": 0.0,
                "__variant_type": 12
            }
        },
        {
            "glslType": "Color",
            "identifier": "colorTint",
            "value": {
                "__variant_value": {
                    "r": 1.0,
                    "g": 1.0,
                    "b": 1.0
                },
                "__variant_type": 10
            }
        },
        {
            "glslType": "Color",
            "identifier": "emissiveColorMultiplier",
            "value": {
                "__variant_value": {
                    "r": 1.0,
                    "g": 1.0,
                    "b": 1.0
                },
                "__variant_type": 10
            }
        },
        {
            "glslType": "float",
            "identifier": "emissiveStrength",
            "value": {
                "__variant_value": 0.0,
                "__variant_type": 3
            }
        },
        {
            "glslType": "vec2",
            "identifier": "UVTiling",
            "value": {
                "__variant_value": {
                    "x": 0.0,
                    "y": 0.0
                },
                "__variant_type": 4
            }
        },
        {
            "glslType": "vec2",
            "identifier": "UVOffset",
            "value": {
                "__variant_value": {
                    "x": 0.0,
                    "y": 0.0
                },
                "__variant_type": 4
            }
        }
    ],
    "vShaderCode": "\n    // Calculate world space of our local attributes..\n    WorldSpace worldSpace = calculateWorldSpace();\n    gl_Position = calculateClipPosition(worldSpace.position);\n    passDataToFragment(worldSpace);     // Pass attributes to fragment shader.. \n",
    "fShaderCode": "\n    // === Handling the 3 properties ===\n    float _roughness; \n    float _metallic; \n    float _occulusion;\n\n    vec2 uv = UVTileAndOffset(fsIn.textureUnit, UVTiling, UVOffset);\n\n    if (toUsePackedMap) {\n        vec3 map = texture(packedMap, uv).rgb;\n        _metallic   = map.r;\n        _roughness  = map.g;\n        _occulusion = map.b;\n    }     \n    else {\n        _roughness  = roughness;\n        _metallic   = metallic;\n        _occulusion = occulusion;\n    }\n\n    // === Handling normal ===\n    vec3 _normal;\n    if(toUseNormalMap) {\n        _normal = getNormalFromMap(normalMap, uv); \n    }\n    else {\n        _normal = normalize(fsIn.normal);\n    }\n\n    vec3 emissiveColor = vec3(0);\n\n    if(toUseEmissiveMap) {\n        emissiveColor = emissiveStrength * emissiveColorMultiplier * vec3(texture(emissiveMap, uv));\n    }\n    \n    vec4 albedo = texture(albedoMap, uv);\n    float resultingAlpha = albedo.a;\n    \n    if(toUseAlphaMap) {\n        resultingAlpha *= texture(alphaMap, uv).r;\n    }\n\n    vec3 pbrColor = PBRCaculation(vec3(albedo) * colorTint, _normal, _roughness, _metallic, _occulusion);\n\n    return vec4(emissiveColor + pbrColor, resultingAlpha);\n",
    "functionsCode": "",
    "pipeline": "PBR"
}
