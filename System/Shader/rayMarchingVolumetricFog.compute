// Reference
// https://lonvanettinger.com/portfolio-pages/fog-ray-march-article-1
#version 450 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define PI 3.141592

// Constants
const float MIN_UNIFORM_TRANSMITTANCE = 0.3; // Uniform darken limit
const float MIN_TRANSMITTANCE = 0.2f; // Optimization to reduce uncessary accumulation calculation

const int MAX_SHADOW_CASTER = 30;

/// Uniforms
// Configurations..
uniform float rayMarchingStepSize;
uniform float maxRayDistance;
uniform float minRayDistance;
uniform float scatteringDensity;
uniform float absorptionDensity;
uniform float scatteringDistribution;

// Renderer input..
uniform sampler2D depthBuffer;
uniform uvec2 screenResolution;
uniform int lightIndex;
uniform float fovY;
uniform sampler2DArray spotlightShadowMaps; 

// Structs
struct Cluster
{
    vec4 minPoint;
    vec4 maxPoint;
    uint pointLightCount;
    uint spotLightCount;
    uint reflectionProbesCount;
    uint pointLightIndices[25];
    uint spotLightIndices[25];
    uint reflectionProbesIndices[4];
};

struct FogData{
    vec3 radiance;
    float transmittance;
};

struct PointLight{
    vec3 position;		
    vec3 viewPosition;
    vec3 color;		
    vec3 attenuation; 
    float radius;
    float intensity;
    int shadowMapIndex;
};

struct SpotLight {
    vec3 position;
    vec3 viewPosition;
    vec3 direction;
    vec3 viewDirection;
    vec3 color;
    vec3 attenuation;
	float cutOffAngle;
	float outerCutOffAngle;
    float radius;
    float intensity;
    int shadowMapIndex;
};

// Uniform Buffers
layout(std140, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 cameraProjectionView;
    mat4 inverseView;
    mat4 inverseProjection;
    mat4 inverseProjectionView;
    mat4 previousViewProjection;    // for TAA

    vec3 cameraPosition;

    uvec3 gridSize;
    uvec2 screenDimensions;
    float zNear;
    float zFar;
};

layout(std140, binding = 1) uniform ShadowCasterMatrixes {
    mat4 shadowCasterMatrix[MAX_SHADOW_CASTER];
};

// SSBO
layout(std430, binding = 0) buffer PointLights {
    uint pointLightCount;
    PointLight pointLights[];
};

layout(std430, binding = 2) buffer SpotLights {
    uint spotLightCount;
    SpotLight spotLights[];
};

layout(std140, binding = 8) buffer VolumetricFogBuffer {
    FogData[] fogDatas;
};

layout(std430, binding = 7) buffer clusterSSBO {
    Cluster clusters[];
};

// Convert from z-depth based on camera to world pos
vec3 DepthToWorldPos(float depth, vec2 uv){
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewSpacePosition = inverseProjection * clipSpacePosition;
    viewSpacePosition /= viewSpacePosition.w;
    vec4 worldSpacePosition = inverseView * viewSpacePosition;

    return worldSpacePosition.xyz;
}

// Convert from z-depth based on camera to view pos
vec3 DepthToViewPos(float depth, vec2 uv){
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewSpacePosition = inverseProjection * clipSpacePosition;
    viewSpacePosition /= viewSpacePosition.w;

    return viewSpacePosition.xyz;
}

float AbsorptionFactor(float fogDensity, float distanceMarched){
    return exp(-fogDensity * distanceMarched);
}

// Schlick phase function approximation of Henyey-Greenstein, decides probability density of scattering directions
float PhaseFunction_Schlick(vec3 w0, vec3 w1){
    float cos_theta = dot(w0,w1);
    float nom = 1.0 - scatteringDistribution * scatteringDistribution;
    float denom = 4.0 * PI * (1.0 + scatteringDistribution * cos_theta) * (1.0 + scatteringDistribution * cos_theta);
    return nom / denom;
}

// Calculates light attenuation.
float calculateAttenuation(float distance, vec3 attenutationFactor, float radius) {
    // Normalize distance by the radius for clamping purposes
    float normalized_distance = distance / radius; 

    // Calculate a factor that goes from 1.0 at d=0 to 0.0 at d=AttenuationRadius
    // The pow(..., 4.0) term helps control the curve, making the cutoff smoother/faster than a simple linear or quadratic function
    float factor_clamped = clamp(1.0 - pow(normalized_distance, 4.0), 0.0, 1.0);

    // Smooth the factor (square it)
    float smooth_factor = factor_clamped * factor_clamped;

    // Apply inverse square attenuation with a small divisor to prevent division by zero near the light source
    // attenutationFactor represents the constants in the attenuation calculation. 
    // attenutationFactor.x is Kc, constant, attenutationFactor.y is Kl, linear and attenutationFactor.z is Kq, quadratic.
    // https://learnopengl.com/Lighting/Light-casters
    float inverse_square_attenuation = 1.0 / (attenutationFactor.x + attenutationFactor.y * distance + attenutationFactor.z * (distance * distance)); 

    // Combine both to get the final attenuation
    float attenuation = smooth_factor * inverse_square_attenuation;

    return attenuation;
}

vec3 getProjectionCoords(vec4 fragmentLightPos) {
    // We perform perspective divide on fragment light position.
    vec3 projCoords = fragmentLightPos.xyz / fragmentLightPos.w;

    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;

    return projCoords;
}

float spotlightShadowCalculation(sampler2DArray spotlightShadowMaps, int shadowMapIndex, vec4 fragmentLightPos) {
    vec3 projCoords = getProjectionCoords(fragmentLightPos);
    
    // Fragment is outside of the shadow map.
    if(projCoords.z > 1.0 || projCoords.z < 0.0) {
        return 0.0;
    }
    
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    
    // check whether current frag pos is in shadow
    float bias = 0;  
    
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(spotlightShadowMaps, 0).xy;
    
    float pcfDepth = texture(spotlightShadowMaps, vec3(projCoords.xy, float(shadowMapIndex))).r; 
    shadow = currentDepth - bias > pcfDepth ? 1.0 : 0.0;        

    return shadow;
}

float getShadowFactor(int lightShadowIndex,vec3 marchPosition) {    
    // doesn't have an active shadow map..
    if(lightShadowIndex == -1) {
        return 0;
    }

    // retrieve shadow caster view projection matrix, to transform fragment world position to light caster's space.
    vec4 fragmentLightPos = shadowCasterMatrix[lightShadowIndex] * vec4(marchPosition, 1);

    return spotlightShadowCalculation(spotlightShadowMaps, lightShadowIndex, fragmentLightPos);
}

vec3 CalculatePointLightScatter(vec3 fragmentToCamera, vec3 lightToMarchPosition, PointLight light){
    vec3 fragmentToCameraNormalized = normalize(fragmentToCamera);
    float visibility = 1.f; // Unless we want to include shadow in the calculation this shouldn't change from 1
    
    float lightDistance = length(lightToMarchPosition);

    vec3 lightIntensity = light.color * light.intensity;
    lightIntensity *= calculateAttenuation(lightDistance, light.attenuation, light.radius); 

    vec3 Lin = AbsorptionFactor(absorptionDensity, lightDistance) * lightIntensity * visibility;
    return Lin * scatteringDensity * light.color * PhaseFunction_Schlick(normalize(lightToMarchPosition), fragmentToCameraNormalized);
}

vec3 CalculateSpotLightScatter(vec3 marchPosition, vec3 fragmentToCamera, vec3 lightToMarchPosition, SpotLight light){
    float lightDistance = length(lightToMarchPosition);
    vec3 l = normalize(lightToMarchPosition);

    vec3 fragmentToCameraNormalized = normalize(fragmentToCamera);
    float visibility = 1.f; // Unless we want to include shadow in the calculation this shouldn't change from 1
    // float visibility = 1.f - getShadowFactor(light.shadowMapIndex, marchPosition); // Unless we want to include shadow in the calculation this shouldn't change from 1
    
    // Cutoff angles for spotlight
    float cutOffAngle       = cos(light.cutOffAngle);
    float outerCutOffAngle  = cos(light.outerCutOffAngle);
    float theta             = dot(l, normalize(light.viewDirection));
    float epsilon           = cutOffAngle - outerCutOffAngle;
    float spotIntensity     = (theta - outerCutOffAngle) / epsilon; 

    if (spotIntensity <= 0.0)
        return vec3(0.0);
    
    vec3 lightIntensity = light.color * light.intensity * spotIntensity;
    lightIntensity *= calculateAttenuation(lightDistance, light.attenuation, light.radius); 

    vec3 Lin = AbsorptionFactor(absorptionDensity, lightDistance) * lightIntensity * visibility;
    return Lin * scatteringDensity * light.color * PhaseFunction_Schlick(normalize(lightToMarchPosition), fragmentToCameraNormalized);
}

uvec3 getClusterFromPos(vec3 viewPos) {
    // X/Y tiles: normalized to screen / frustum size
    float aspect = screenDimensions.x / screenDimensions.y;
    float tanFovY = tan(fovY * 0.5);

    float xNorm = (viewPos.x / (-viewPos.z * tanFovY * aspect)) * 0.5 + 0.5;
    float yNorm = (viewPos.y / (-viewPos.z * tanFovY)) * 0.5 + 0.5;

    uint xTile = uint(clamp(xNorm * gridSize.x, 0.0, float(gridSize.x-1)));
    uint yTile = uint(clamp(yNorm * gridSize.y, 0.0, float(gridSize.y-1)));

    // Z tile (logarithmic)
    uint zTile = uint((log(-viewPos.z / zNear) * float(gridSize.z)) / log(zFar / zNear));
    zTile = min(zTile, gridSize.z - 1u);

    return uvec3(xTile, yTile, zTile);
}

Cluster getCluster(vec3 viewPos) {
    uvec3 tile = getClusterFromPos(viewPos);
    uint tileIndex = tile.x + tile.y * gridSize.x + tile.z * gridSize.x * gridSize.y;
    return clusters[tileIndex];
}

Cluster getCluster(vec3 viewPos, vec2 fragCoord) {
    uint zTile = uint((log(abs(viewPos.z) / zNear) * gridSize.z) / log(zFar / zNear));      // we find the z value of this tile..
    vec2 tileSize = screenDimensions / gridSize.xy;                                     
    uvec3 tile = uvec3(fragCoord / tileSize, zTile);                                        // we found our tile index for x, y and z.
    uint tileIndex = tile.x + (tile.y * gridSize.x) + (tile.z * gridSize.x * gridSize.y);   // convert it to index.

    return clusters[tileIndex];
}

Cluster getClusterForSlice(uint slice, vec2 fragCoord) {
    vec2 tileSize = screenDimensions / gridSize.xy;                                     
    uvec3 tile = uvec3(fragCoord / tileSize, slice);                                        // we found our tile index for x, y and z.
    uint tileIndex = tile.x + (tile.y * gridSize.x) + (tile.z * gridSize.x * gridSize.y);   // convert it to index.

    return clusters[tileIndex];
}

// based on the view position's z, get the z slice of the cluster..
uint computeZSlice(float viewZ) {
    float zNorm = log(viewZ / zNear) / log(zFar / zNear);
    return uint(clamp(zNorm * gridSize.z, 0.0, gridSize.z - 1.0));
}

float computeEndZ(uint slice) {
    return zNear * pow(zFar / zNear, float(slice + 1) / gridSize.z);
}

float computeStartZ(uint slice) {
    return zNear * pow(zFar / zNear, float(slice) / gridSize.z);
}

// We are doing everything in VIEW SPACE!!
void main(){
    // ====================================================================== 
    // 1. Setup variables..
    // ====================================================================== 

    vec2 uv = vec2(float(gl_GlobalInvocationID.x) / screenResolution.x, float(gl_GlobalInvocationID.y) / screenResolution.y);
    float z = texture(depthBuffer, uv).r;

    // We need fragment view position & fragment's current cluster
    vec3 viewPos = DepthToViewPos(z, uv);   // which essientially represents view directional vector too.
    vec2 fragCoord = uv * screenDimensions; // screen space coordinate if we were following the original resolution.

    // Ray Marching information with distance limit
    vec3 rayDirection = normalize(viewPos);
    float rayDistance = min(length(viewPos), maxRayDistance) - minRayDistance;

    // Ray Marching
    vec3 marchPosition = rayDirection * minRayDistance;
    vec3 deltaStep = rayDirection * rayMarchingStepSize;
    vec3 fragmentToCamera = -rayDirection;

    // Accumulate transmittance and radiance for the current pixel from each light
    uint fogIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * screenResolution.x;

    fogDatas[fogIndex].radiance = vec3(0.0);
    fogDatas[fogIndex].transmittance = 0.0;

    float transmittance = 1;

#if 0
    // We don't want to query clusters every raymarch, we wanna keep track of the begin and end z slice of the cluster..
    float currDistance = 0;
    float accumulatedDistance = 0;

    while (currDistance < rayDistance) {
        float viewZ = -marchPosition.z;
        uint slice = computeZSlice(viewZ);
        Cluster cluster = getClusterForSlice(slice, fragCoord);

        float sliceEndZ = computeEndZ(slice);

        float zStep = abs(rayDirection.z);
        float sliceEndT = sliceEndZ / zStep;

        // We progress, because current distance
        float targetT = min(sliceEndT, rayDistance);
        if (targetT <= currDistance) {
            currDistance += rayMarchingStepSize;
            marchPosition += deltaStep;
            continue;
        }

        for(; currDistance < min(sliceEndT, rayDistance); currDistance += rayMarchingStepSize){
            transmittance *= AbsorptionFactor(absorptionDensity, rayMarchingStepSize);

            // In-Scattering calculation
            for(uint i = 0; i < cluster.pointLightCount; ++i) {
                PointLight light = pointLights[cluster.pointLightIndices[i]];
                vec3 lightToMarchPosition = marchPosition - light.viewPosition;
                vec3 Li = CalculatePointLightScatter(fragmentToCamera, lightToMarchPosition, light);
                fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
            }
            
            for(uint i = 0; i < cluster.spotLightCount; ++i) {
                SpotLight light = spotLights[cluster.spotLightIndices[i]];
                // CalculatedSpotLight calculatedSpotLight = calculatedSpotLights[i];
                vec3 lightToMarchPosition = marchPosition - light.viewPosition;
                vec3 Li = CalculateSpotLightScatter(marchPosition, fragmentToCamera, lightToMarchPosition, light);
                fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
            }

            marchPosition += deltaStep;
        }
    }
#else
    for(float currDistance = 0; currDistance <= rayDistance; currDistance += rayMarchingStepSize) {
        transmittance *= AbsorptionFactor(absorptionDensity, rayMarchingStepSize);

        // In-Scattering calculation
        for(int i = 0;i<pointLightCount;++i){
            // Accumulation
            PointLight light = pointLights[i];
            vec3 lightToMarchPosition = marchPosition - light.viewPosition;
            vec3 Li = CalculatePointLightScatter(fragmentToCamera, lightToMarchPosition, light);
            fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
        }
            
        for(int i = 0;i<spotLightCount;++i){
            // Accumulation
            SpotLight light = spotLights[i];
            vec3 lightToMarchPosition = marchPosition - light.viewPosition;
            vec3 Li = CalculateSpotLightScatter(marchPosition,fragmentToCamera, lightToMarchPosition, light);
            fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
        }

        marchPosition += deltaStep;
    }

#endif

    // Max sure it doesn't get too dark
    fogDatas[fogIndex].transmittance = max(MIN_TRANSMITTANCE, transmittance);
}