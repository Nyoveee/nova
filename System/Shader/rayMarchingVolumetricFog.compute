// Reference
// https://lonvanettinger.com/portfolio-pages/fog-ray-march-article-1
#version 450 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define PI 3.141592

// Constants
const float MIN_UNIFORM_TRANSMITTANCE = 0.3; // Uniform darken limit
const float MIN_TRANSMITTANCE = 0.01f; // Optimization to reduce uncessary accumulation calculation

const int MAX_SHADOW_CASTER = 15;

/// Uniforms
// Configurations..
uniform float rayMarchingStepSize;
uniform float maxRayDistance;
uniform float scatteringDensity;
uniform float absorptionDensity;
uniform float scatteringDistribution;

// Renderer input..
uniform sampler2D depthBuffer;
uniform uvec2 screenResolution;
uniform int lightIndex;
uniform sampler2DArray spotlightShadowMaps; 

// Structs
struct FogData{
    vec3 radiance;
    float transmittance;
};

struct PointLight{
    vec3 position;		
    vec3 color;		
    vec3 attenuation; 
    float radius;
    float intensity;
    int shadowMapIndex;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    vec3 color;
    vec3 attenuation;
	float cutOffAngle;
	float outerCutOffAngle;
    float radius;
    float intensity;
    int shadowMapIndex;
};

// Uniform Buffers
layout(std140, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 cameraProjectionView;
    vec3 cameraPosition;

    uvec3 gridSize;
    uvec2 screenDimensions;
    float zNear;
    float zFar;
};

layout(std140, binding = 1) uniform ShadowCasterMatrixes {
    mat4 shadowCasterMatrix[MAX_SHADOW_CASTER];
};

// SSBO
layout(std430, binding = 0) buffer PointLights {
    uint pointLightCount;
    PointLight pointLights[];
};

layout(std430, binding = 2) buffer SpotLights {
    uint spotLightCount;
    SpotLight spotLights[];
};

layout(std140, binding = 8) buffer VolumetricFogBuffer {
    FogData[] fogDatas;
};

// Convert from z-depth based on camera to world pos
vec3 DepthToWorldPos(float depth, vec2 uv){
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewSpacePosition = inverse(projection) * clipSpacePosition;
    viewSpacePosition /= viewSpacePosition.w;
    vec4 worldSpacePosition = inverse(view) * viewSpacePosition;

    return worldSpacePosition.xyz;
}

float AbsorptionFactor(float fogDensity, float distanceMarched){
    return exp(-fogDensity * distanceMarched);
}

// Schlick phase function approximation of Henyey-Greenstein, decides probability density of scattering directions
float PhaseFunction_Schlick(vec3 w0, vec3 w1){
    float cos_theta = dot(w0,w1);
    float nom = 1.0 - scatteringDistribution * scatteringDistribution;
    float denom = 4.0 * PI * (1.0 + scatteringDistribution * cos_theta) * (1.0 + scatteringDistribution * cos_theta);
    return nom / denom;
}

vec3 CalculatePointLightScatter(vec3 fragmentToCamera, vec3 lightToMarchPosition, PointLight light){
    vec3 fragmentToCameraNormalized = normalize(fragmentToCamera);
    float visibility = 1.f; // Unless we want to include shadow in the calculation this shouldn't change from 1
    
    float lightDistance = length(lightToMarchPosition);
    float phi = light.intensity;
    float denom = 4.0 * PI * lightDistance * lightDistance;
    vec3 Lin = AbsorptionFactor(absorptionDensity, lightDistance) * light.color * light.intensity * visibility * phi/denom;
    return Lin * scatteringDensity * light.color * PhaseFunction_Schlick(normalize(lightToMarchPosition), fragmentToCameraNormalized);
}

vec3 getProjectionCoords(vec4 fragmentLightPos) {
    // We perform perspective divide on fragment light position.
    vec3 projCoords = fragmentLightPos.xyz / fragmentLightPos.w;

    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;

    return projCoords;
}

float spotlightShadowCalculation(sampler2DArray spotlightShadowMaps, int shadowMapIndex, vec4 fragmentLightPos) {
    vec3 projCoords = getProjectionCoords(fragmentLightPos);
    
    // Fragment is outside of the shadow map.
    if(projCoords.z > 1.0 || projCoords.z < 0.0) {
        return 0.0;
    }
    
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    
    // check whether current frag pos is in shadow
    float bias = 0;  
    
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(spotlightShadowMaps, 0).xy;
    
    float pcfDepth = texture(spotlightShadowMaps, vec3(projCoords.xy, float(shadowMapIndex))).r; 
    shadow = currentDepth - bias > pcfDepth ? 1.0 : 0.0;        

    return shadow;
}

float getShadowFactor(int lightShadowIndex,vec3 marchPosition) {    
    // doesn't have an active shadow map..
    if(lightShadowIndex == -1) {
        return 0;
    }

    // retrieve shadow caster view projection matrix, to transform fragment world position to light caster's space.
    vec4 fragmentLightPos = shadowCasterMatrix[lightShadowIndex] * vec4(marchPosition, 1);

    return spotlightShadowCalculation(spotlightShadowMaps, lightShadowIndex, fragmentLightPos);
}

vec3 CalculateSpotLightScatter(vec3 marchPosition, vec3 fragmentToCamera, vec3 lightToMarchPosition, SpotLight light){
    float lightDistance = length(lightToMarchPosition);
    vec3 l = normalize(lightToMarchPosition);

    vec3 fragmentToCameraNormalized = normalize(fragmentToCamera);
    float visibility = 1.f - getShadowFactor(light.shadowMapIndex, marchPosition); // Unless we want to include shadow in the calculation this shouldn't change from 1
    
    // Cutoff angles for spotlight
    float cutOffAngle       = cos(light.cutOffAngle);
    float outerCutOffAngle  = cos(light.outerCutOffAngle);
    float theta             = dot(l, normalize(light.direction));
    float epsilon           = cutOffAngle - outerCutOffAngle;
    float spotIntensity     = (theta - outerCutOffAngle) / epsilon; 
    if (spotIntensity <= 0.0)
        return vec3(0.0);
    
    float phi = light.intensity;
    float denom = 4.0 * PI * lightDistance * lightDistance;

    vec3 Lin = AbsorptionFactor(absorptionDensity, lightDistance) * light.color * light.intensity * spotIntensity * visibility * phi/denom;
    return Lin * scatteringDensity * light.color * PhaseFunction_Schlick(normalize(lightToMarchPosition), fragmentToCameraNormalized);
}


void main(){
    // Get fragment world position based on depth of a specific pixel
    vec2 uv = vec2(float(gl_GlobalInvocationID.x) / screenResolution.x, float(gl_GlobalInvocationID.y) / screenResolution.y);
    float z = texture(depthBuffer, uv).r;
    vec3 fragmentPosition = DepthToWorldPos(z, uv);

    // Ray Marching information with distance limit
    vec3 rayDirection = normalize(fragmentPosition - cameraPosition);
    float rayDistance = min(length(fragmentPosition - cameraPosition), maxRayDistance);

    // Ray Marching
    vec3 marchPosition = cameraPosition;
    vec3 deltaStep = rayDirection * rayMarchingStepSize;

    // Accumulate transmittance and radiance for the current pixel from each light
    uint fogIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * screenResolution.x;
    vec3 fragmentToCamera = cameraPosition - fragmentPosition;

    fogDatas[fogIndex].radiance = vec3(0.0);
    fogDatas[fogIndex].transmittance = 0.0;

    float transmittance = 1;

    for(float currDistance = 0; currDistance <= rayDistance; currDistance += rayMarchingStepSize){
       transmittance *= AbsorptionFactor(absorptionDensity, rayMarchingStepSize);
       // Early out if transmittance is too low, too low transmittance doesn't contribute much to radiance
       if(transmittance <= MIN_TRANSMITTANCE)
           break;

        // In-Scattering calculation
       for(int i = 0;i<pointLightCount;++i){
            // Accumulation
            PointLight light = pointLights[i];
            vec3 lightToMarchPosition = marchPosition - light.position;
            vec3 Li = CalculatePointLightScatter(fragmentToCamera, lightToMarchPosition, light);
            fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
        }
        for(int i = 0;i<spotLightCount;++i){
            // Accumulation
            SpotLight light = spotLights[i];
            vec3 lightToMarchPosition = marchPosition - light.position;
            vec3 Li = CalculateSpotLightScatter(marchPosition,fragmentToCamera, lightToMarchPosition, light);
            fogDatas[fogIndex].radiance += Li * transmittance * rayMarchingStepSize;
        }
        marchPosition += deltaStep;
    }

    // Max sure it doesn't get too dark
    fogDatas[fogIndex].transmittance = max(MIN_UNIFORM_TRANSMITTANCE,transmittance);
}