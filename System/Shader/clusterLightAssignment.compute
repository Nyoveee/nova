#version 450 core

#define LOCAL_SIZE 128
layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

// https://github.com/DaveH355/clustered-shading?tab=readme-ov-file

struct Cluster
{
    vec4 minPoint;
    vec4 maxPoint;
    uint pointLightCount;
    uint spotLightCount;
    uint reflectionProbesCount;
    uint pointLightIndices[25];
    uint spotLightIndices[25];
    uint reflectionProbesIndices[4];
};

layout(std430, binding = 7) buffer clusterSSBO
{
    Cluster clusters[];
};

// === LIGHT PROPERTIES ===
struct PointLight{
    vec3 position;		
    vec3 color;		
    vec3 attenuation; 
    float radius;
    float intensity;
};

struct DirectionalLight {
    vec3 direction;
    vec3 color;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    vec3 color;
    vec3 attenuation;
	float cutOffAngle;
	float outerCutOffAngle;
    float radius;
};

struct ReflectionProbe {
	vec3 worldMin;
	vec3 worldMax;
    vec3 viewMin;
	vec3 viewMax;
    vec3 worldProbePosition;
    int indexToProbeArray;
    float blendFallOff;
    float intensity;
};

layout(std430, binding = 0) buffer PointLights {
    uint pointLightCount;
    PointLight pointLights[];
};

layout(std430, binding = 1) buffer DirectionalLights {
    uint dirLightCount;
    DirectionalLight dirLights[];
};

layout(std430, binding = 2) buffer SpotLights {
    uint spotLightCount;
    SpotLight spotLights[];
};

layout(std140, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 cameraProjectionView;
    vec3 cameraPosition;

    uvec3 gridSize;
    uvec2 screenDimensions;
    float zNear;
    float zFar;
};

layout(std140, binding = 3) uniform ReflectionProbes {
    uint reflectionProbesCount;
    ReflectionProbe reflectionProbes[30];
};

bool sphereAABBIntersection(vec3 center, float radius, vec3 aabbMin, vec3 aabbMax) {
    // closest point on the AABB to the sphere center
    vec3 closestPoint = clamp(center, aabbMin, aabbMax);
    // squared distance between the sphere center and closest point
    float distanceSquared = dot(closestPoint - center, closestPoint - center);
    return distanceSquared <= radius * radius;
}

bool AABBIntersection(vec3 aabbMin1, vec3 aabbMax1, vec3 aabbMin2, vec3 aabbMax2) {
    // Check for separation along X, Y, Z axes
    if (aabbMax1.x < aabbMin2.x || aabbMin1.x > aabbMax2.x) return false;
    if (aabbMax1.y < aabbMin2.y || aabbMin1.y > aabbMax2.y) return false;
    if (aabbMax1.z < aabbMin2.z || aabbMin1.z > aabbMax2.z) return false;

    // No separation found
    return true;
}

// each invocation of main() is a thread processing a cluster
void main() {
    // Get cluster..
    uint index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;
    Cluster cluster = clusters[index];

    // We deal with all point lights first..
    cluster.pointLightCount = 0;

    for (uint i = 0; i < pointLightCount && cluster.pointLightCount < 25; ++i) {
        // Get the position of point light in view space.
        vec3 viewPos = vec3(view * vec4(pointLights[i].position, 1.0));

        // Check if a given light's influence intersects with cluster AABB.
        if(sphereAABBIntersection(viewPos, pointLights[i].radius, cluster.minPoint.xyz, cluster.maxPoint.xyz)){
            cluster.pointLightIndices[cluster.pointLightCount] = i;
            cluster.pointLightCount++;
        }
    }

    // We now deal with spot lights..
    cluster.spotLightCount = 0;

    for (uint i = 0; i < spotLightCount && cluster.spotLightCount < 25; ++i) {
        // Get the position of point light in view space.
        vec3 viewPos = vec3(view * vec4(spotLights[i].position, 1.0));

        // Check if a given light's influence intersects with cluster AABB.
        if(sphereAABBIntersection(viewPos, spotLights[i].radius, cluster.minPoint.xyz, cluster.maxPoint.xyz)){
            cluster.spotLightIndices[cluster.spotLightCount] = i;
            cluster.spotLightCount++;
        }
    }

    // We now deal with reflection probes.. xD
    cluster.reflectionProbesCount = 0;

    for (uint i = 0; i < reflectionProbesCount && cluster.reflectionProbesCount < 4; ++i) {
        // Get reflection probe..
        ReflectionProbe reflectionProbe = reflectionProbes[i];

        // Check if the reflection probe AABB intersect with cluster AABB..
        if(AABBIntersection(reflectionProbe.viewMin, reflectionProbe.viewMax, cluster.minPoint.xyz, cluster.maxPoint.xyz)){
            cluster.reflectionProbesIndices[cluster.reflectionProbesCount] = i;
            cluster.reflectionProbesCount++;
        }
    }

    clusters[index] = cluster;
}