#version 450 core
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct ParticleVertex{
	vec4 color;
	vec3 position;
	float rotation;
	float currentSize;
};
struct Particle{
    vec4 startColor;
    vec4 endColor;
    vec3 velocity;
    vec3 force;
    vec3 lightattenuation;
    float colorInterpolation;
    float sizeInterpolation;
    float lightIntensity;
    float lightRadius;
    float angularVelocity;
    float startSize;
    float endSize;
    float currentLifeTime;
    float lifeTime;
    bool colorOverLifetime;
    bool sizeOverLifetime;
    bool velocityBasedRotation;
    bool b_Active;
};

layout(std430, binding = 4) buffer ParticleVertexList {
    ParticleVertex particleVertices[];
};

layout(std430, binding = 5) buffer ParticleList {
    int particleCount;
    Particle particles[];
};

layout(std140, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 cameraProjectionView;
    mat4 inverseView;
    mat4 inverseProjection;
    mat4 inverseProjectionView;
    mat4 previousViewProjection;    // for TAA

    vec3 cameraPosition;
   
    uvec3 gridSize;
    uvec2 screenDimensions;
    float zNear;
    float zFar;
};

uniform float dt;  

float InterpolationFloat(float start, float end, float t, float degree){
    return start + (end - start) * pow(t, 1.f / degree);
}

vec4 InterpolationVector(vec4 start, vec4 end, float t, float degree) {
    float x = InterpolationFloat(start.x, end.x, t, degree);
    float y = InterpolationFloat(start.y, end.y, t, degree);
    float z = InterpolationFloat(start.z, end.z, t, degree);
    float w = InterpolationFloat(start.w, end.w, t, degree);
    return vec4(x,y,z,w);
}

void main() {
    uint particleIndex = gl_GlobalInvocationID.x;
    if(particleIndex >= particleCount || !particles[particleIndex].b_Active)
        return;
    particles[particleIndex].currentLifeTime -= dt;
    // Set this particle to be removed once it reach end of lifetime
    if (particles[particleIndex].currentLifeTime <= 0) {
        particles[particleIndex].b_Active = false;
	    return;
    }
    // Movement
    particleVertices[particleIndex].position += particles[particleIndex].velocity * dt;
    particles[particleIndex].velocity += particles[particleIndex].force * dt;

    if(particles[particleIndex].velocityBasedRotation){
        vec2 screenSpaceVelocity = normalize((cameraProjectionView * vec4( particles[particleIndex].velocity,0.0)).xy);
        vec2 up = vec2(0,1.0);
        vec2 right = vec2(1.0,0);
        float velocityRotation = -sign(dot(right,screenSpaceVelocity)) * acos(dot(up, screenSpaceVelocity));
        particleVertices[particleIndex].rotation = velocityRotation;
    }
    else{
        particleVertices[particleIndex].rotation += particles[particleIndex].angularVelocity * dt;
    }
       
    // Color
    if (particles[particleIndex].colorOverLifetime) {
	    float interpolationValue = 1 - particles[particleIndex].currentLifeTime / particles[particleIndex].lifeTime;
	    float degree = particles[particleIndex].colorInterpolation;
	    particleVertices[particleIndex].color = InterpolationVector(particles[particleIndex].startColor, 
                                                                    particles[particleIndex].endColor, 
                                                                    interpolationValue, 
                                                                    degree);
    }
    // Size
    if (particles[particleIndex].sizeOverLifetime) {
	    float interpolationValue = 1 - particles[particleIndex].currentLifeTime / particles[particleIndex].lifeTime;
	    float degree = particles[particleIndex].sizeInterpolation;
	    particleVertices[particleIndex].currentSize = InterpolationFloat(particles[particleIndex].startSize, 
                                                                         particles[particleIndex].endSize, 
                                                                         interpolationValue, 
                                                                         degree);
    }
}
